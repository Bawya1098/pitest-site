---
title: Mutation operators
description: Details of mutation operators provided with PIT
tags: mutators
keywords: mutation testing, mutation operator
layout: default
permalink: /quickstart/mutators/
---

# Overview

PIT currently provides some built-in mutators, of which most are activated by default. The default set can be overridden, and different operators selected, by passing the names of the required operators to the **mutators** parameter. 

Mutations are performed on the byte code generated by the compiler rather than on the source files. This approach has the advantage of being generally much faster and easier to incorporate into a build, but it can sometimes be difficult to simply describe how the mutation operators map to equivalent changes to a Java source file.

The operators are largely designed to be **stable** (i.e not be too easy to detect) and minimise the number of equivalent mutations that they generate. Those operators that do not meet these requirements are not enabled by default.

# Available mutators

We'll briefly describe the available mutators in the following sections. See the [test cases](#TEST_CASES) for
more detailed examples.

Here is the list of available mutators:

(*activated by default*)
- [Conditionals Boundary Mutator](#CONDITIONALS_BOUNDARY)
- [Increments Mutator](#INCREMENTS)
- [Invert Negatives Mutator](#INVERT_NEGS)
- [Math Mutator](#MATH)
- [Negate Conditionals Mutator](#NEGATE_CONDITIONALS)
- [Return Values Mutator](#RETURN_VALS)
- [Void Method Calls Mutator](#VOID_METHOD_CALLS)

(*deactivated by default*)
- [Constructor Calls Mutator](#CONSTRUCTOR_CALLS)
- [Inline Constant Mutator](#INLINE_CONSTS)
- [Non Void Method Calls Mutator](#NON_VOID_METHOD_CALLS)
- [Remove Conditionals Mutator](#REMOVE_CONDITIONALS)
- [Experimental Member Variable Mutator](#EXPERIMENTAL_MEMBER_VARIABLE)
- [Experimental Switch Mutator](#EXPERIMENTAL_SWITCH)
- [Negation Mutator](#EXPERIMENTAL_ABS)
- [Arithmetic Operator Replacement Mutator](#EXPERIMENTAL_AOR)
- [Arithmetic Operator Deletion Mutator](#EXPERIMENTAL_AOD)
- [Constant Replacement Mutator](#EXPERIMENTAL_CRCR)
- [Bitwise Operator Mutator](#EXPERIMENTAL_OBBN)
- [Relational Operator Replacement Mutator](#EXPERIMENTAL_ROR)
- [Unary Operator Insertion Mutator](#EXPERIMENTAL_UOI)

See the current [code](https://github.com/hcoles/pitest/blob/master/pitest/src/main/java/org/pitest/mutationtest/engine/gregor/config/Mutator.java) for current list (latest development version).

----

<a name="CONDITIONALS_BOUNDARY" id="CONDITIONALS_BOUNDARY"></a>

Conditionals Boundary Mutator (CONDITIONALS_BOUNDARY)
-----------------------------------------------------

**Active by default**

The conditionals boundary mutator replaces the relational operators `<, <=, >, >=` 

with their boundary counterpart as per the table below.

<table class="table">
    <thead>
        <tr>
            <th>
            Original conditional
            </th>
            <th>
            Mutated conditional
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>&lt;</td>
            <td>&lt;=</td>
        </tr>
        <tr>
            <td>&lt;=</td>
            <td>&lt;</td>
        </tr>
        <tr>
            <td>&gt;</td>
            <td>&gt;=</td>
        </tr>
        <tr>
            <td>&gt;=</td>
            <td>&gt;</td>
        </tr>
    </tbody>
</table>

For example

```java
if (a < b) {
  // do something
}
```

will be mutated to

```java
if (a <= b) {
  // do something
}
```

<a name="NEGATE_CONDITIONALS" id="NEGATE_CONDITIONALS"></a>

Negate Conditionals Mutator (NEGATE_CONDITIONALS)
-------------------------------------------------

**Active by default**

The negate conditionals mutator will mutate all conditionals found according
to the replacement table below.

<table class="table">
    <thead>
        <tr>
            <th>
            Original conditional
            </th>
            <th>
            Mutated conditional
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>==</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>!=</td>
            <td>==</td>
        </tr>
        <tr>
            <td>&lt;=</td>
            <td>&gt;</td>
        </tr>
        <tr>
            <td>&gt;=</td>
            <td>&lt;</td>
        </tr>
        <tr>
            <td>&lt;</td>
            <td>&gt;=</td>
        </tr>
        <tr>
            <td>&gt;</td>
            <td>&lt;=</td>
        </tr>

    </tbody>
</table>

For example

```java
if (a == b) {
  // do something
}
```

will be mutated to

```java
if (a != b) {
  // do something
}
```

This mutator overlaps to a degree with the conditionals boundary mutator, but is less **stable** i.e these
mutations are generally easier for a test suite to detect.


<a name="REMOVE_CONDITIONALS" id="REMOVE_CONDITIONALS"></a>

Remove Conditionals Mutator (REMOVE_CONDITIONALS)
-------------------------------------------------

The remove conditionals mutator will remove all conditionals statements such that the guarded statements always
execute

For example


```java
if (a == b) {
  // do something
}
```

will be mutated to

```java
if (true) {
  // do something
}
```

Although not currently enabled by default it is highly recommended that you enable it if you wish to ensure your test suite has full coverage of conditional statements.

As shown above the basic remove conditionals mutator ensures that the statements following the conditional always execute. It will also only mutate only equality checks (eg ==, !=).

Additional specialised versions of the mutator exist that will ensure the block never executes so

```java
if (a == b) {
  // do something
}
```

will be mutated to

```java
if (false) {
  // do something
}
```

If an else block is present it will always execute 

```java
if (a == b) {
  // do something
} else {
  // do something else
}
```

will be mutated to

```java
if (false) {
  // do something
} else {
  // do something else
}
```

Specialisations also exist that will mutate the bytecode instructions for order checks (eg <=, >).

The available specialisations are

* REMOVE_CONDITIONALS_EQ_IF
* REMOVE_CONDITIONALS_EQ_ELSE
* REMOVE_CONDITIONALS_ORD_IF
* REMOVE_CONDITIONALS_ORD_ELSE

The names reflect which branch will be forced to execute (the "if" or the "else") and the type of checks that will be mutated. 

The reason these are not enabled by default is that there is a large degree of overlap in the tests required to kill these mutations and those required to kill mutations from other default operators such as the conditional boundaries mutator.

<a name="MATH" id="MATH"></a>

Math Mutator (MATH)
-------------------

**Active by default**

The math mutator replaces binary arithmetic operations for either integer or 
floating-point arithmetic with another operation. The replacements will be 
selected according to the table below.

<table class="table">
    <thead>
        <tr>
            <th>
            Original conditional
            </th>
            <th>
            Mutated conditional
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>+</td>
            <td>-</td>
        </tr>
        <tr>
            <td>-</td>
            <td>+</td>
        </tr>
        <tr>
            <td>*</td>
            <td>/</td>
        </tr>
        <tr>
            <td>/</td>
            <td>*</td>
        </tr>
        <tr>
            <td>%</td>
            <td>*</td>
        </tr>
        <tr>
            <td>&amp;</td>
            <td>|</td>
        </tr>
        <tr>
            <td>|</td>
            <td>&amp;</td>
        </tr>
        <tr>
            <td>^</td>
            <td>&amp;</td>
        </tr>
        <tr>
            <td>&lt;&lt;</td>
            <td>&gt;&gt;</td>
        </tr>
        <tr>
            <td>&gt;&gt;</td>
            <td>&lt;&lt;</td>
        </tr>
        <tr>
            <td>&gt;&gt;&gt;</td>
            <td>&lt;&lt;</td>
        </tr>
    </tbody>
</table>


For example

```java
int a = b + c;
```

will be mutated to

```java
int a = b - c;
```

Keep in mind that the `+` operator on `String`s as in

```java
String a = "foo" + "bar";
```

is **not a mathematical operator** but a string concatenation and will be 
replaced by the compiler with something like

```java
String a = new StringBuilder("foo").append("bar").toString();
```


Please note that the compiler will also use binary arithmetic operations for
increments, decrements and assignment increments and decrements of non-local
variables (member variables) although a special `iinc` opcode for increments 
exists. This special opcode is restricted to local variables (also called stack
variables) and cannot be used for member variables. That means the math mutator
will also mutate

```java
public class A {
  private int i;

  public void foo() {
    this.i++;
  }
}
```

to

```java
public class A {
  private int i;

  public void foo() {
    this.i = this.i - 1;
  }
}
```

See the [Increments Mutator](#INCREMENTS) for details.

<a name="INCREMENTS" id="INCREMENTS"></a>

Increments Mutator (INCREMENTS)
-------------------------------

**Active by default**

The increments mutator will mutate increments, decrements and assignment
increments and decrements of local variables (stack variables). It will replace
increments with decrements and vice versa.

For example

```java
public int method(int i) {
  i++;
  return i;
}
```

will be mutated to

```java
public int method(int i) {
  i--;
  return i;
}
```

Please note that the increments mutator will be applied to increments of 
**local variables only**. Increments and decrements of member variables will be
covered by the [Math Mutator](#MATH).

<a name="INVERT_NEGS" id="INVERT_NEGS"></a>

Invert Negatives Mutator (INVERT_NEGS)
--------------------------------------

**Active by default**

The invert negatives mutator inverts negation of integer and floating point 
numbers. For example

```java
public float negate(final float i) {
  return -i;
}
```

will be mutated to

```java
public float negate(final float i) {
  return i;
}
```

<a name="INLINE_CONSTS" id="INLINE_CONSTS"></a>

Inline Constant Mutator (INLINE_CONSTS)
---------------------------------------

The inline constant mutator mutates inline constants. An inline constant is a
literal value assigned to a non-final variable, for example

```java
public void foo() {
  int i = 3;
  // do something with i
}
```

Depending on the type of the inline constant another mutation is used. The rules
are a little complex due to the different ways that apparently similar Java statements
are converted to byte code.


<table class="table">
    <thead>
        <tr>
            <th>Constant Type</th>
            <th>Mutation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>boolean</code></td>
            <td>
                replace the unmutated value <code>true</code> with <code>false</code> and
                replace the unmutated value <code>false</code> with <code>true</code>
            </td>
        </tr>
        <tr>
            <td><code>integer</code> <code>byte</code> <code>short</code></td>
            <td>
                replace the unmutated value <code>1</code> with <code>0</code>,
                <code>-1</code> with <code>1</code>, <code>5</code> with <code>-1</code>
                or otherwise increment the unmutated value by one. <a href="#fn1"><sup>1</sup></a> <a name="fnref1" id="fnref1"></a>
            </td>
        </tr>
        <tr>
            <td><code>long</code></td>
            <td>
                replace the unmutated value <code>1</code> with <code>0</code>, otherwise
                increment the unmutated value by one.
            </td>
        </tr>
        <tr>
            <td><code>float</code></td>
            <td>
                replace the unmutated values <code>1.0</code> and <code>2.0</code>
                with <code>0.0</code> and replace any other value with <code>1.0</code> <a href="#fn2"><sup>2</sup></a> <a name="fnref2" id="fnref2"></a>
            </td>
        </tr>
        <tr>
            <td><code>double</code></td>
            <td>
                replace the unmutated value <code>1.0</code> with <code>0.0</code>
                and replace any other value with <code>1.0</code> <a href="#fn3"><sup>3</sup></a> <a name="fnref3" id="fnref3"></a>
            </td>
        </tr>
    </tbody>
</table>

For example

```java
public int foo() {
  int i = 42;
  return i;
}
```

will be mutated to

```java
public int foo() {
  int i = 43;
  return i;
}
```

Please note that the compiler might optimize the use of final variables 
(regardless whether those are stack variables or member variables). For example
the following code

```java
public class A {
  private static final int VAR = 13;
  
  public String foo() {
    final int i = 42;
    return "" + VAR + ":" + i;
  }
}
```

will be changed/optimized by the compiler to

```java
public class A {
  public String foo() {
    return "13:42";
  }
}
```

In such situations the mutation engine can not mutate any variable.

<a name="RETURN_VALS" id="RETURN_VALS"></a>

Return Values Mutator (RETURN_VALS)
-----------------------------------

**Active by default**

The return values mutator mutates the return values of method calls. Depending
on the return type of the method another mutation is used.<a href="#fn4"><sup>4</sup></a> <a name="fnref4" id="fnref4"></a>

<table class="table">
    <thead>
        <tr>
            <th>Return Type</th>
            <th>Mutation</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>boolean</code></td>
            <td>
                replace the unmutated return value <code>true</code> with <code>false</code> and
                replace the unmutated return value <code>false</code> with <code>true</code>
            </td>
        </tr>
        <tr>
            <td><code>int</code> <code>byte</code> <code>short</code></td>
            <td>
                if the unmutated return value is <code>0</code> return <code>1</code>, otherwise
                mutate to return value <code>0</code>
            </td>
        </tr>
        <tr>
            <td><code>long</code></td>
            <td>
                replace the unmutated return value <code>x</code> with the result of <code>x+1</code>
            </td>
        </tr>
        <tr>
            <td><code>float</code> <code>double</code></td>
            <td>
                replace the unmutated return value <code>x</code> with the result of
                <code>-(x+1.0)</code> if <code>x</code> is not <code>NAN</code> and
                replace <code>NAN</code> with <code>0</code>
            </td>
        </tr>
        <tr>
            <td><code>Object</code></td>
            <td>
                replace non-<code>null</code> return values with <code>null</code> and throw a
                <code>java.lang.RuntimeException</code> if the unmutated method
                would return <code>null</code>
            </td>
        </tr>
    </tbody>
</table>

For example

```java
public Object foo() {
  return new Object();
}
```

will be mutated to

```java
public Object foo() {
  new Object();
  return null;
}
```

<a name="VOID_METHOD_CALLS" id="VOID\_METHOD\_CALLS"></a>

Void Method Call Mutator (VOID_METHOD_CALLS)
--------------------------------------------

**Active by default**

The void method call mutator removes method calls to void methods. For example

```java
public void someVoidMethod(int i) {
  // does something
}

public int foo() {
  int i = 5;
  doSomething(i);
  return i;
}
```

will be mutated to

```java
public void someVoidMethod(int i) {
  // does something
}

public int foo() {
  int i = 5;
  return i;
}
```

Please note that constructor calls are **not considered void method calls**.
See the [Constructor Call Mutator](#CONSTRUCTOR_CALL) for mutations of 
constructors or the [Non Void Method Call Mutator](#NON_VOID_METHOD_CALL) for
mutations of non void methods.


<a name="TRUE_RETURNS" id="TRUE_RETURNS"></a>

True returns Mutator (TRUE\_RETURNS)
-------------------------------------

Replaces primitive and boxed boolean return values with true.

Pitest will filter out equivalent mutations to methods that are already hard coded to return true.


<a name="FALSE_RETURNS" id="FALSE_RETURNS"></a>

False returns Mutator (FALSE\_RETURNS)
-------------------------------------

Replaces primitive and boxed boolean return values with false.

Pitest will filter out equivalent mutations to methods that are already hard coded to return false.

<a name="PRIMITIVE_RETURNS" id="PRIMITIVE_RETURNS"></a>

Primitive returns Mutator (PRIMITIVE\_RETURNS)
----------------------------------------------

Replaces int, short, long, char, float and double return values with 0.

Pitest will filter out equivalent mutations to methods that are already hard coded to return 0.

<a name="EMPTY_RETURNS" id="EMPTY_RETURNS"></a>

Empty returns Mutator (EMPTY\_RETURNS)
--------------------------------------

Replaces return values with an 'empty' value for that type as follows

* java.lang.String -> ""
* java.util.Optional -> Optional.empty()
* java.util.List -> Collections.emptyList()
* java.util.Collection -> Collections.emptyList()
* java.util.Set -> Collections.emptySet()
* java.lang.Integer -> 0
* java.lang.Short -> 0
* java.lang.Long -> 0
* java.lang.Character -> 0
* java.lang.Float -> 0
* java.lang.Double -> 0

Pitest will filter out equivalent mutations to methods that are already hard coded to return the empty value.

<a name="NULL_RETURNS" id="NULL_RETURNS"></a>

Null returns Mutator (NULL\_RETURNS)
--------------------------------------

Replaces return values with null. Methods that can be mutated by the EMPTY_RETURNS mutator or that are directly annotated with NotNull will not be mutated.

Pitest will filter out equivalent mutations to methods that are already hard coded to return null.

<a name="NON_VOID_METHOD_CALLS" id="NON_VOID_METHOD_CALLS"></a>

Non Void Method Call Mutator (NON\_VOID\_METHOD\_CALLS)
----------------------------------------------------

The non void method call mutator removes method calls to non void methods.
Their return value is replaced by the Java Default Value for that specific
type. See the table below.

Table: Java Default Values for Primitives and Reference Types


<table class="table">
    <thead>
        <tr>
            <th>Type</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>boolean</code></td>
            <td><code>false</code></td>
        </tr>
        <tr>
            <td><code>int</code> <code>byte</code> <code>short</code> <code>long</code></td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td><code>float</code> <code>double</code></td>
            <td><code>0.0</code></td>
        </tr>
        <tr>
            <td><code>char</code></td>
            <td><code>'\u0000'</code></td>
        </tr>
        <tr>
            <td><code>Object</code></td>
            <td><code>null</code></td>
        </tr>
    </tbody>
</table>

For example

```java
public int someNonVoidMethod() {
  return 5;
}

public void foo() {
  int i = someNonVoidMethod();
  // do more stuff with i
}
```

will be mutated to

```java
public int someNonVoidMethod() {
  return 5;
}

public void foo() {
  int i = 0;
  // do more stuff with i
}
```

and for method calls returning an object type the call

```java
public Object someNonVoidMethod() {
  return new Object();
}

public void foo() {
  Object o = someNonVoidMethod();
  // do more stuff with o
}
```

will be mutated to

```java
public Object someNonVoidMethod() {
  return new Object();
}

public void foo() {
  Object o = null;
  // do more stuff with o
}
```

Please note that this mutation is fairly unstable for some types (especially Objects where
**`NullPointerException`s** are likely) and may also create equivalent mutations if
it replaces a method that already returns one of the default values without also having
a side effect.

This mutator does not affect void methods or constructor calls. See 
[Void Method Call Mutator](#VOID_METHOD_CALL) for mutations of void methods and
[Constructor Call Mutator](#CONSTRUCTOR_CALL) for mutations of constructors.

<a name="CONSTRUCTOR_CALLS" id="CONSTRUCTOR_CALLS"></a>

Constructor Call Mutator (CONSTRUCTOR_CALLS)
--------------------------------------------

The constructor call mutator replaces constructor calls with `null` values. For
example

```java
public Object foo() {
  Object o = new Object();
  return o;
}
```

will be mutated to

```java
public Object foo() {
  Object o = null;
  return o;
}
```

Please note that this mutation is fairly unstable and likely to cause **`NullPointerException`s** even
with weak test suites.

This mutator does not affect non constructor method calls. See [Void Method Call Mutator](#VOID_METHOD_CALL) for 
mutations of void methods and
[Non Void Method Call Mutator](#NON_VOID_METHOD_CALL) for mutations of non void
methods.

<a name="EXPERIMENTAL_MEMBER_VARIABLE" id="EXPERIMENTAL_MEMBER_VARIABLE"></a>
Experimental Member Variable Mutator (EXPERIMENTAL\_MEMBER\_VARIABLE)
-------------------------------------------------------------------

The experimental member variable mutator mutates classes by removing assignments
to member variables. The mutator can even remove assignments to final members.
The members will be initialized with their Java Default Value for the specific
type. See the table below.

Table: Java Default Values for Primitives and Reference Types

<table class="table">
    <thead>
        <tr>
            <th>Type</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <code>boolean</code>
            </td>
            <td>`false`</td>
        </tr>
        <tr>
            <td>
                <code>int</code>
                <code>short</code>
                <code>byte</code>
                <code>long</code>
            </td>
            <td>`0`</td>
        </tr>
        <tr>
            <td>
                <code>float</code>
                <code>double</code>
            </td>
            <td>`0.0`</td>
        </tr>
        <tr>
            <td>
                <code>char</code>
            </td>
            <td>`'\u0000'`</td>
        </tr>
        <tr>
            <td>
                <code>Object</code>
            </td>
            <td>`null`</td>
        </tr>
    </tbody>
</table>

For example

```java
public class MutateMe {
    private final int x = 5;
    //...
}
```

will be mutated to

```java
  public class MutateMe {
    private final int x = 0;
    ...
  }
```

**Please Note: This mutator is likely to create equivalent mutations** if a
member variable is **explicitly** initialized with the Java default value for 
the specific type of the member variable as in

```java
public class EquivalentMutant {
    private int x = 0;
}
```

<a name="EXPERIMENTAL_SWITCH" id="EXPERIMENTAL_SWITCH"></a>

Experimental Switch Mutator (EXPERIMENTAL_SWITCH)
-------------------------------------------------

The switch mutator finds the first label within a switch statement that differs from the default label. It mutates the switch statement by replacing the default label (wherever it is used) with this label. All the other labels are replaced by the default one.

*Thanks to Stefan Penndorf who contributed this documentation.*

<a name="ABS" id="EXPERIMENTAL_ABS"></a>

Negation Mutator (ABS)
-------------------------------------------------
This mutator replace any use of a numeric variable (local valiable, field, array cell) with its negation. For example:
```java
public float get(final float i) {
  return i;
}
```

will be mutated to

```java
public float get(final float i) {
  return -i;
}
```
<a name="AOR" id="EXPERIMENTAL_AOR"></a>

Arithmetic Operator Replacement Mutator (AOR)
-------------------------------------------------
Like the math mutator, this mutator replaces binary arithmetic operations for either integer or floating-point arithmetic with another operation. The mutator is composed of 4 sub-mutators (AOR_1 to AOR_4) that mutate operators according to the table below.
<table>
    <thead>
        <tr>
            <th>
            Original operator
            </th>
            <th>
            AOR_1
            </th>
            <th>
            AOR_2
            </th>
            <th>
            AOR_3
            </th>
            <th>
            AOR_4
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>+</td>
            <td>-</td>
            <td>*</td>
            <td>/</td>
            <td>%</td>
        </tr>
        <tr>
            <td>-</td>
            <td>+</td>
            <td>*</td>
            <td>/</td>
            <td>%</td>
        </tr>
        <tr>
            <td>*</td>
            <td>/</td>
            <td>%</td>
            <td>+</td>
            <td>-</td>
        </tr>
        <tr>
            <td>/</td>
            <td>*</td>
            <td>%</td>
            <td>+</td>
            <td>-</td>
        </tr>
        <tr>
            <td>%</td>
            <td>*</td>
            <td>/</td>
            <td>+</td>
            <td>-</td>
        </tr>
    </tbody>
</table>

<a name="AOD" id="EXPERIMENTAL_AOD"></a>

Arithmetic Operator Deletion Mutator (AOD)
-------------------------------------------------
This mutator replaces an arithmetic operation with one of its members. The mutator is composed of 2 sub-mutators, AOD_1 and AOD_2, that mutate the operation to its first and second member respectively.
For example

```java
int a = b + c;
```

will be mutated to

```java
int a = b;
```

and to

```java
int a = c;
```

<a name="CRCR" id="EXPERIMENTAL_CRCR"></a>

Constant Replacement Mutator (CRCR)
-------------------------------------------------
Like the inline constant mutator, this mutator mutates inline constant. The mutator is composed of 6 sub-mutators (CRCR1 to CRCR6) that mutate constants according to the table below.
<table>
    <thead>
        <tr>
            <th>
            Constant
            </th>
            <th>
            CRCR1
            </th>
            <th>
            CRCR2
            </th>
            <th>
            CRCR3
            </th>
            <th>
            CRCR4
            </th>
            <th>
            CRCR5
            </th>
            <th>
            CRCR6
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>c</td>
            <td>1</td>
            <td>0</td>
            <td>-1</td>
            <td>-c</td>
            <td>c+1</td>
            <td>c-1</td>
        </tr>
    </tbody>
</table>

<a name="OBBN" id="EXPERIMENTAL_OBBN"></a>

Bitwise Operator Mutator (OBBN)
-------------------------------------------------
This mutator mutates bitwise and (&) and or (|). It is composed of three sub-mutators, OBBN1, OBBN2 and OBBN3 that respectively reverse the operators, replace a bitwise operation by its first member, and by its second member.
For example

```java
a & b;
```

will be mutated to

```java
a | b;
```

by OBBN1, to

```java
a;
```

by OBBN2 and to

```java
b;
```

by OBBN3.

<a name="ROR" id="EXPERIMENTAL_ROR"></a>

Relational Operator Replacement Mutator (ROR)
-------------------------------------------------
This mutator replaces a relational operator with another one. The mutator is composed of 5 sub-mutators (ROR1 to ROR5) that mutate the operators according to the table below.
<table>
    <thead>
        <tr>
            <th>
            Original operator
            </th>
            <th>
            ROR_1
            </th>
            <th>
            ROR_2
            </th>
            <th>
            ROR_3
            </th>
            <th>
            ROR_4
            </th>
            <th>
            ROR_5
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>&lt;</td>
            <td>&lt;=</td>
            <td>&gt;</td>
            <td>&gt;=</td>
            <td>==</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>&lt;=</td>
            <td>&lt;</td>
            <td>&gt;</td>
            <td>&gt;=</td>
            <td>==</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>&gt;</td>
            <td>&lt;</td>
            <td>&lt;=</td>
            <td>&gt;=</td>
            <td>==</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>&gt;=</td>
            <td>&lt;</td>
            <td>&lt;=</td>
            <td>&gt;</td>
            <td>==</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>==</td>
            <td>&lt;</td>
            <td>&lt;=</td>
            <td>&gt;</td>
            <td>&gt;=</td>
            <td>!=</td>
        </tr>
        <tr>
            <td>!=</td>
            <td>&lt;</td>
            <td>&lt;=</td>
            <td>&gt;</td>
            <td>&gt;=</td>
            <td>==</td>
        </tr>
    </tbody>
</table>

<a name="UOI" id="EXPERIMENTAL_UOI"></a>

Unary Operator Insertion (UOI)
-------------------------------------------------
This mutator inserts a unary operator (increment or decrement) to a variable call. It affects local variables, parameters and array variables. It is composed of 4 sub-mutators, UOI1 to UOI4 that insert operators according to the table below.
<table>
    <thead>
        <tr>
            <th>
            Variable
            </th>
            <th>
            UOI1
            </th>
            <th>
            UOI2
            </th>
            <th>
            UOI3
            </th>
            <th>
            UOI4
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>a</td>
            <td>a++</td>
            <td>a--</td>
            <td>++a</td>
            <td>--a</td>
        </tr>
    </tbody>
</table>

<hr/>
1. <a name="fn1" id="fn1"></a> Integer numbers and booleans are actually represented in the same way be the JVM,
  it is therefore never safe if change a 0 to anything but a 1 or a 1 to anything but a 0.
  [↩](#fnref1)
2. <a name="fn2" id="fn2"></a> Floating point numbers are always changed to 1 rather than adding 1 to the original value
  as this would result in equivalent mutations. Adding 1 to a large floating point number
  doesn't necessarily change its value due to the imprecise way in which floats are represented.
  [↩](#fnref2)
3. <a name="fn3" id="fn3"></a> See note above which applies to both floats and doubles. [↩](#fnref3)
4. <a name="fn4" id="fn4"></a> The strategy used by this mutator was translated from code in the Jumble project
  [↩](#fnref4)
